\documentclass[10pt]{amsart}

\usepackage{amssymb,hyperref}
% \linespread{1.2}
\usepackage[
hmarginratio={1:1},     % equal left and right margins
vmarginratio={1:1},     % equal top and bottom margins
textwidth=400pt,        % new text width
heightrounded,          % always useful
%%bindingcorrection=5mm,  % binding correction
]{geometry}
%opening
\title{Fast 3D Node generation with variable density in Matlab}
\author{}
\date{\today}

\newcommand{\cube}{\mathcal{C}}

\begin{document}

\maketitle

\section{Overview}
The aim is to develop a method for distributing nodes on arbitrarily shaped domains in a way that would 
\begin{itemize}
 \item be suitable for mesh-free PDE discretizations using RBFs, i.e., produced well-separated and locally regular node sets;
 \item allow for a variable density function;
 \item be massively parallel.
\end{itemize}
\section{Unit cube}

Suppose a function on the unit cube  $\rho: \mathcal{I} =[0,1]^3 \to [0,D)$ prescribing the local node density is given.  Consider the following algorithm for generating nodes with this density: 

\begin{enumerate}
	
	\item Partition $\mathcal{I}$ into $N_\text{c}^3$ subcubes of side length $1/N_\text{c}$. The choice of $N_\text{c}$ corresponds to the  density resolution of the final node set. Prescribe $n_\text{max}$ to be the maximum number of nodes in each subcube of the inital distribution. 
	The density, $N_\text{c}$, and $n_\text{max}$ can be scaled to change the total number of desired nodes $N$. 
%	Experimentally, choosing $n_\text{max} = 20$ and $N_\text{c}$ such that there are approximately $N/10$ total cubes seems to be a good choice.
	
	\item On a subcube $\cube$, let $\bar{\rho}_\cube$ be the average of the values of $\rho$ at the corners of $A$. The algorithm then fills the subcube with an appropriately scaled number of nodes 
	\[  n_\cube = \lfloor  n_\text{max}\frac{ \bar{\rho}_\cube }{D} \rfloor.  \] 
	The nodes are generated by an irrationally rotated lattice,  scaled and translated to $\cube$:
	\[\bigg(\frac{i}{n_\cube}, \bigg\{\alpha\frac{i}{n_\cube}\bigg\}, \bigg\{\beta\frac{i}{n_\cube}\bigg\}\bigg), \qquad i=1\dots n_\cube, \quad  \alpha, \beta\in\mathbb{R}\setminus\mathbb{Q}\]
	where $\left\{x\right\}:= x-\left\lfloor x\right\rfloor$ denotes the fractional part of $x$. While any irrational values of $\alpha$ and $\beta$ will give an equidistributed lattice as $n_\cube$ grows, certain values  may perform better than others. In particular, adjustments can be made to provide better distribution for small $n_\cube$. We currently use $\alpha = \sqrt{2}, \beta = \sqrt{5}$.
	
	\item Electrostatically repel the points in $m$ steps using the $k$ nearest neighbors of each point. The current implementation has $k=15$ and the number of repel steps can be adjusted based on desired speed. For the $i^{th}$ repel step, given a point $y$ with nearest neighbors $\left\{x_j\right\}_{j=1}^k$ form the weighted vector sum
	\[x = \sum_{j=1}^{k}\frac{y-x_j}{|y-x_j|^s} \]
	for some $s>3$ and move $y$ away from the direction of $x$. That is,
	\[y\mapsto y - \frac{\delta_y}{(i+1)}\frac{x}{|x|}\]
	where $\delta_y$ denotes the nearest neighbor distance to $y$. The $kNN$ tree is not recomputed for each repel step.
\end{enumerate}
This algorithm generates ??? nodes in ??? seconds and ($ \sim $1 million nodes) in ??? seconds.

[Insert Trui pictures]



\section{Matlab code}

The Git repository containing Matlab code is available at \texttt{\url{https://github.com/OVlasiuk/3dRBFnodes.git}}.

\section{Future Work}

Several outstanding issues remain. 
\begin{itemize}
\item The generation of the lattice on each subcube should be improved. We are working on transforming the lattice so that the density varies linearly within each subcube. This would make the density of the initial point generation more accurate and fewer repulsion steps would be needed.
\item The current code does not handle general boundaries beside the cube. Ideally the node distribution restricted to the boundary should be a reasonable 2D node distribution of variable density.
\item We are working on parallelizing the repulsion steps and implementing the algorithm on a GPU.
\end{itemize}

\end{document}
